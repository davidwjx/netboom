; Script generated by the Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!

#define MyAppName "InuDev"
#define MyAppVersion "1.00.0000.00"
#define MyAppPublisher "Inuitive"
#define MyAppURL "http://www.inuitive-tech.com/"
#define MyAppExeName "InuView.exe"
#define OpenCVDir GetEnv('OPENCV300_DIR')

[Setup]
; NOTE: The value of AppId uniquely identifies this application.
; Do not use the same AppId value in installers for other applications.
; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)
AppId={{3652B280-8F0B-449C-8D1C-0F29260BF0C9}
AppName={#MyAppName}
AppVersion={#MyAppVersion}
;AppVerName={#MyAppName} {#MyAppVersion}
AppPublisher={#MyAppPublisher}
AppPublisherURL={#MyAppURL}
AppSupportURL={#MyAppURL}
AppUpdatesURL={#MyAppURL}
ArchitecturesInstallIn64BitMode=x64
DefaultDirName={pf64}\Inuitive\{#MyAppName}
DefaultGroupName=Inuitive\{#MyAppName}
OutputBaseFilename=InuDevPro_{#MyAppVersion}_Setup_X64
OutputDir=.
;Password=Inu590
Compression=lzma
SolidCompression=yes
SignTool=SignTool /d $qInuDevPro_{#MyAppVersion}_Setup_X64$q /du $qhttp://www.inuitive-tech.com$q $f

[Languages]
Name: "english"; MessagesFile: "compiler:Default.isl"

[Tasks]
;Name: "desktopicon"; Description: "{cm:CreateDesktopIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked
Name: "quicklaunchicon"; Description: "{cm:CreateQuickLaunchIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked; OnlyBelowVersion: 0,6.1

[Icons]
Name: "{group}\InuSpector"; Filename: "{app}\bin\InuSpector.exe"; WorkingDir: "{app}\bin"; IconFilename: "{app}\config\icons\InuSpector.ico"; IconIndex: 0
Name: "{group}\{cm:UninstallProgram,{#MyAppName}}"; Filename: "{uninstallexe}"
;Name: "{commondesktop}\{#MyAppName}"; Filename: "{app}\bin\{#MyAppExeName}"; WorkingDir: "{app}\bin"; Tasks: desktopicon
Name: "{userappdata}\Microsoft\Internet Explorer\Quick Launch\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"; Tasks: quicklaunchicon
Name: "{group}\InuView"; Filename: "{app}\bin\InuView.exe"; WorkingDir: "{app}\bin"; IconFilename: "{app}\config\icons\InuViewer.ico"
Name: "{group}\include"; Filename: "{app}\include"
Name: "{group}\lib"; Filename: "{app}\lib"
Name: "{group}\docs"; Filename: "{app}\docs"

[Run]
;Filename: "{app}\bin\{#MyAppExeName}"; Description: "{cm:LaunchProgram,{#StringChange(MyAppName, '&', '&&')}}"; Flags: nowait postinstall skipifsilent
Filename: "{sys}\taskkill.exe"; Parameters: "/f /im InuView.exe"; Flags: skipifdoesntexist runhidden
Filename: "{sys}\taskkill.exe"; Parameters: "/f /im InuSpector.exe"; Flags: skipifdoesntexist runhidden
Filename: "{sys}\taskkill.exe"; Parameters: "/f /im mmc.exe"; Flags: skipifdoesntexist runhidden; AfterInstall: ExecDriverInstallation
;Filename: "{app}\bin\DriverInstallation.exe"; Parameters: "{app}"; Flags: runascurrentuser runhidden; Description: "InuDriver Install"
Filename: "{sys}\sc.exe"; Parameters: "create InuService start= auto binPath= ""{app}\bin\InuService.exe"""; Flags: runhidden
Filename: "{sys}\sc.exe"; Parameters: "failure InuService reset= 86400 actions= restart/10000/restart/10000/restart/10000"; Flags: runhidden
Filename: "{sys}\sc.exe"; Parameters: "start InuService"; Flags: runhidden; AfterInstall: MySleep
; Filename: "{sys}\sc.exe"; Parameters: "stop InuService"; Flags: runhidden; AfterInstall: sleep(20000)
; Filename: "{sys}\sc.exe"; Parameters: "start InuService"; Flags: runhidden
Filename: "{sys}\netsh.exe"; Parameters: "http add urlacl url=http://+:8000/Inuitive/InuView user=Everyone"; WorkingDir: "{sys}"; Flags: runhidden

[UninstallRun]
Filename: "{sys}\sc.exe"; Parameters: "stop InuService"; Flags: runhidden; AfterInstall: sleep(5000)
Filename: "{sys}\taskkill.exe"; Parameters: "/f /im InuView.exe"; Flags: skipifdoesntexist runhidden
Filename: "{sys}\taskkill.exe"; Parameters: "/f /im InuSpector.exe"; Flags: skipifdoesntexist runhidden
Filename: "{sys}\taskkill.exe"; Parameters: "/f /im mmc.exe"; Flags: skipifdoesntexist runhidden
Filename: "{sys}\taskkill.exe"; Parameters: "/f /im InuService.exe"; Flags: skipifdoesntexist runhidden
Filename: "{sys}\sc.exe"; Parameters: "delete InuService"; Flags: runhidden
Filename: "{sys}\netsh.exe"; Parameters: "http del urlacl url=http://+:8000/Inuitive/InuView"; WorkingDir: "{sys}"; Flags: runhidden

[PreCompile]
Name: "{app}\bin\PreInstallation.exe"; Parameters: """{app}"""; Flags: runminimized

[ThirdParty]
UseRelativePaths=True

[Registry]
Root: "HKLM"; Subkey: "SYSTEM\ControlSet001\Control\Session Manager\Environment"; ValueType: none; ValueName: "INUITIVE_PATH"; Flags: deletevalue uninsdeletevalue

[Dirs]
Name: {code:GetDataDir}; Flags: uninsneveruninstall

[UninstallDelete]
Type: filesandordirs; Name: "{app}\bin\boot*\*"

[Code]
var
  UsagePage: TInputOptionWizardPage;
  UserPage: TInputQueryWizardPage;
  LightMsgPage: TOutputMsgWizardPage;
  KeyPage: TInputQueryWizardPage;
  ProgressPage: TOutputProgressWizardPage;
  DataDirPage: TInputDirWizardPage;
  Page: TInputOptionWizardPage;
  IsRegisteredUser: Boolean;
  DriverInstallationResultCode: integer;
  CancelWithoutPrompt: boolean;
  IsVerySilent: boolean;

procedure InitializeWizard;
begin
  { Create the pages }

Page := CreateInputOptionPage(wpFinished,
  'Sensor final reconnection', 'Please re-connect the sensor',
  'ONCE DONE, please check the box below, then click Next.',
  False, True);

// Add items
Page.Add('Please RECONNECT the sensor.  Then - check this box');

// Set initial values (optional)
Page.Values[0] := False;

// Read values into variables
IsRegisteredUser := Page.Values[0];


  UsagePage := CreateInputOptionPage(wpFinished,
     'Sensor insertion', 'Please insert sensor to USB port of your computer',
    'Press NEXT button when done.',
     True, False);

  UsagePage := CreateInputOptionPage(wpFinished,
     'Sensor Re-Insertion', 'Please Re-Insert sensor to USB port of your computer',
    'Press NEXT button when done.',
     True, False);

  UserPage := CreateInputQueryPage(wpFinished,
    'Personal Information', 'Who are you?',
    'Please specify your name and the company for whom you work, then click Next.');
  UserPage.Add('Name:', False);
  UserPage.Add('Company:', False);

  LightMsgPage := CreateOutputMsgPage(UsagePage.ID,
    'Sensor insertion', 'Please insert sensor to USB port of your computer',
    'Click Back if you want to change your usage mode setting now, or click Next to ' +
    'continue with the installation.');

 KeyPage := CreateInputQueryPage(UsagePage.ID,
    'Personal Information', 'What''s your registration key?',
    'Please specify your registration key and click Next to continue. If you don''t ' +
    'have a valid registration key, click Back to choose a different usage mode.');
  KeyPage.Add('Registration key:', False);

  ProgressPage := CreateOutputProgressPage('Personal Information',
    'What''s your registration key?');

  DataDirPage := CreateInputDirPage(wpFinished,
    'Select Personal Data Directory', 'Where should personal data files be installed?',
    'Select the folder in which Setup should install personal data files, then click Next.',
    False, '');
  DataDirPage.Add('');  

  { Set default values, using settings that were stored last time if possible }

  UserPage.Values[0] := GetPreviousData('Name', ExpandConstant('{sysuserinfoname}'));
  UserPage.Values[1] := GetPreviousData('Company', ExpandConstant('{sysuserinfoorg}'));

  case GetPreviousData('UsageMode', '') of
    'light': UsagePage.SelectedValueIndex := 0;
    'sponsored': UsagePage.SelectedValueIndex := 1;
    'paid': UsagePage.SelectedValueIndex := 2;
  else
    UsagePage.SelectedValueIndex := 1;
  end;

  DataDirPage.Values[0] := GetPreviousData('DataDir', '');
end;

procedure RegisterPreviousData(PreviousDataKey: Integer);
var
  UsageMode: String;
begin
  { Store the settings so we can restore them next time }
  SetPreviousData(PreviousDataKey, 'Name', UserPage.Values[0]);
  SetPreviousData(PreviousDataKey, 'Company', UserPage.Values[1]);
  case UsagePage.SelectedValueIndex of
    0: UsageMode := 'light';
    1: UsageMode := 'sponsored';
    2: UsageMode := 'paid';
  end;
  SetPreviousData(PreviousDataKey, 'UsageMode', UsageMode);
  SetPreviousData(PreviousDataKey, 'DataDir', DataDirPage.Values[0]);
end;

function ShouldSkipPage(PageID: Integer): Boolean;
begin
  { Skip pages that shouldn't be shown }
  if (PageID = LightMsgPage.ID) and (UsagePage.SelectedValueIndex <> 0) then
    Result := True
  else if (PageID = KeyPage.ID) and (UsagePage.SelectedValueIndex <> 2) then
    Result := True
  else
    Result := False;
end;

procedure ExecDriverInstallation() ;
  { Skip pages that shouldn't be shown }
begin
    WizardForm.ProgressGauge.Min := 0;
    WizardForm.ProgressGauge.Max := 100;
    WizardForm.ProgressGauge.Position := 10;
    DriverInstallationResultCode := 0;
    if NOT Exec(ExpandConstant('{app}\bin\DriverInstallation.exe'), '', '', 
             SW_HIDE, ewWaitUntilTerminated, DriverInstallationResultCode) Then
        MsgBox('Driver is not installed or not updated', mbError, MB_OK);
    if  DriverInstallationResultCode = 1  then
    begin
        CancelWithoutPrompt := true;
        WizardForm.Close;
    end;
end;

procedure CheckForFileMsvcp140() ;
var
  ErrCode: integer;
begin
  if NOT FileExists(ExpandConstant('{sys}\msvcp140.dll')) then
  begin
    if MsgBox('Your system requires installation of Microsoft Visual C++ 2015 x64 Redistributable. Accordingly, installation process will be cancelled now. Would you like to visit the download page now?', mbConfirmation, MB_YESNO) = IDYES
    then begin
      ShellExecAsOriginalUser('open', 'https://www.microsoft.com/en-us/download/details.aspx?id=48145','', '', SW_SHOW, ewNoWait, ErrCode);
    end;
    CancelWithoutPrompt := true;
    WizardForm.Close;
  end;
end;

procedure IsMSVCRedist64Installed() ;
var
  ErrCode: integer;
begin
  if not RegKeyExists(HKLM64, 'SOFTWARE\Wow6432Node\Microsoft\DevDiv\vc\Servicing\11.0\RuntimeMinimum') then
  begin
    if MsgBox('Your system requires installation of Microsoft Visual C++ 2012 x64 Redistributable. Accordingly, installation process will be cancelled now. Would you like to visit the download page now?', mbConfirmation, MB_YESNO) = IDYES
    then begin
      ShellExecAsOriginalUser('open', 'http://www.microsoft.com/en-us/download/details.aspx?id=30679','', '', SW_SHOW, ewNoWait, ErrCode);
    end;
    CancelWithoutPrompt := true;
    WizardForm.Close;
  end;
end;

procedure IsMSVC2015Redist64Installed() ;
var
  ErrCode: integer;
begin
  if not RegKeyExists(HKLM64, 'SOFTWARE\Classes\Installer\Dependencies\{3ee5e5bb-b7cc-4556-8861-a00a82977d6c}') then
  begin
    if MsgBox('Your system requires installation of Microsoft Visual C++ 2015 x64 Redistributable. Accordingly, installation process will be cancelled now. Would you like to visit the download page now?', mbConfirmation, MB_YESNO) = IDYES
    then begin
      ShellExecAsOriginalUser('open', 'https://www.microsoft.com/en-us/download/details.aspx?id=48145','', '', SW_SHOW, ewNoWait, ErrCode);
    end;
    CancelWithoutPrompt := true;
    WizardForm.Close;
  end;
end;

procedure CancelButtonClick(CurPageID: Integer; var Cancel, Confirm: Boolean);
begin
  Cancel := true;
  Confirm := false;
end;

procedure MySleep() ;
  var
   I: integer;
   J: integer;
begin
  if  DriverInstallationResultCode = 1  then
  begin 
    try
      for I := 0 to 19 do begin
        WizardForm.ProgressGauge.Position := 40 + I * 2;
        Sleep(1000);
      end;
    finally
      WizardForm.ProgressGauge.Position := 80;
   end;
end else
      WizardForm.ProgressGauge.Position := 80;

      IsVerySilent := False;
      for J := 1 to ParamCount do
          if CompareText(ParamStr(J), '/verysilent') = 0 then
          begin
              IsVerySilent := True;
              Break;
          end; 

      if IsVerySilent = False then
      begin
          Log ('Not VerySilent');
          MsgBox('In order to complete the installation please reconnect sensor', mbError, MB_OK);
          for I := 0 to 3 do begin
              WizardForm.ProgressGauge.Position := 80 + I * 5;
              Sleep(1000);
          end;
      end;
end;

function NextButtonClick(CurPageID: Integer): Boolean;
var
  I: Integer;
begin
  { Validate certain pages before allowing the user to proceed }
  if CurPageID = UserPage.ID then begin
    if UserPage.Values[0] = '' then begin
      MsgBox('You must enter your name.', mbError, MB_OK);
      Result := False;
    end else begin
      if DataDirPage.Values[0] = '' then
        DataDirPage.Values[0] := 'C:\' + UserPage.Values[0];
      Result := True;
    end;
  end else if CurPageID = KeyPage.ID then begin
    { Just to show how 'OutputProgress' pages work.
      Always use a try..finally between the Show and Hide calls as shown below. }
    ProgressPage.SetText('Authorizing registration key...', '');
    ProgressPage.SetProgress(0, 0);
    ProgressPage.Show;
    try
      for I := 0 to 10 do begin
        ProgressPage.SetProgress(I, 10);
        Sleep(100);
      end;
    finally
      ProgressPage.Hide;
    end;
    if GetSHA1OfString('codedlg' + KeyPage.Values[0]) = '8013f310d340dab18a0d0cda2b5b115d2dcd97e4' then
      Result := True
    else begin
      MsgBox('You must enter a valid registration key. (Hint: The key is "inno".)', mbError, MB_OK);
      Result := False;
    end;
  end else
    Result := True;
end;

function UpdateReadyMemo(Space, NewLine, MemoUserInfoInfo, MemoDirInfo, MemoTypeInfo,
  MemoComponentsInfo, MemoGroupInfo, MemoTasksInfo: String): String;
var
  S: String;
begin
  { Fill the 'Ready Memo' with the normal settings and the custom settings }
  S := '';
  S := S + 'Personal Information:' + NewLine;
  S := S + Space + UserPage.Values[0] + NewLine;
  if UserPage.Values[1] <> '' then
    S := S + Space + UserPage.Values[1] + NewLine;
  S := S + NewLine;
  
  S := S + 'Usage Mode:' + NewLine + Space;
  case UsagePage.SelectedValueIndex of
    0: S := S + 'Light mode';
    1: S := S + 'Sponsored mode';
    2: S := S + 'Paid mode';
  end;
  S := S + NewLine + NewLine;
  
  S := S + MemoDirInfo + NewLine;
  S := S + Space + DataDirPage.Values[0] + ' (personal data files)' + NewLine;

  Result := S;
end;

function GetUser(Param: String): String;
begin
  { Return a user value }
  { Could also be split into separate GetUserName and GetUserCompany functions }
  if Param = 'Name' then
    Result := UserPage.Values[0]
  else if Param = 'Company' then
    Result := UserPage.Values[1];
end;

function GetDataDir(Param: String): String;
begin
  { Return the selected DataDir }
  Result := DataDirPage.Values[0];
end;

/////////////////////////////////////////////////////////////////////
function GetUninstallString(): String;
var
  sUnInstPath: String;
  sUnInstallString: String;
begin
  sUnInstPath := ExpandConstant('Software\Microsoft\Windows\CurrentVersion\Uninstall\{#emit SetupSetting("AppId")}_is1');
  sUnInstallString := '';
  if not RegQueryStringValue(HKLM, sUnInstPath, 'UninstallString', sUnInstallString) then
    RegQueryStringValue(HKCU, sUnInstPath, 'UninstallString', sUnInstallString);
  Result := sUnInstallString;
end;


/////////////////////////////////////////////////////////////////////
function IsUpgrade(): Boolean;
begin
  Result := (GetUninstallString() <> '');
end;


/////////////////////////////////////////////////////////////////////
function UnInstallOldVersion(): Integer;
var
  sUnInstallString: String;
  iResultCode: Integer;
begin
// Return Values:
// 1 - uninstall string is empty
// 2 - error executing the UnInstallString
// 3 - successfully executed the UnInstallString

  // default return value
  Result := 0;

  // get the uninstall string of the old app
  sUnInstallString := GetUninstallString();
  if sUnInstallString <> '' then begin
    sUnInstallString := RemoveQuotes(sUnInstallString);
    if Exec(sUnInstallString, '/SILENT /NORESTART /SUPPRESSMSGBOXES','', SW_HIDE, ewWaitUntilTerminated, iResultCode) then
      Result := 3
    else
      Result := 2;
  end else
    Result := 1;
end;

/////////////////////////////////////////////////////////////////////
procedure CurStepChanged(CurStep: TSetupStep);
begin
  if (CurStep=ssInstall) then
  begin
    if (IsUpgrade()) then
    begin
      UnInstallOldVersion();
    end;
  end;
end;

// function IsServiceInstalled(ServiceName: string) : boolean;
// function IsServiceRunning(ServiceName: string) : boolean;
// function InstallService(FileName, ServiceName, DisplayName, Description : string;ServiceType,StartType :cardinal) : boolean;
// function RemoveService(ServiceName: string) : boolean;
// function StartService(ServiceName: string) : boolean;
// function StopService(ServiceName: string) : boolean;
// function SetupService(service, port, comment: string) : boolean;

type
    SERVICE_STATUS = record
        dwServiceType               : cardinal;
        dwCurrentState              : cardinal;
        dwControlsAccepted          : cardinal;
        dwWin32ExitCode             : cardinal;
        dwServiceSpecificExitCode   : cardinal;
        dwCheckPoint                : cardinal;
        dwWaitHint                  : cardinal;
    end;
    HANDLE = cardinal;

const
    SERVICE_QUERY_CONFIG        = $1;
    SERVICE_CHANGE_CONFIG       = $2;
    SERVICE_QUERY_STATUS        = $4;
    SERVICE_START               = $10;
    SERVICE_STOP                = $20;
    SERVICE_ALL_ACCESS          = $f01ff;
    SC_MANAGER_ALL_ACCESS       = $f003f;
    SERVICE_WIN32_OWN_PROCESS   = $10;
    SERVICE_WIN32_SHARE_PROCESS = $20;
    SERVICE_WIN32               = $30;
    SERVICE_INTERACTIVE_PROCESS = $100;
    SERVICE_BOOT_START          = $0;
    SERVICE_SYSTEM_START        = $1;
    SERVICE_AUTO_START          = $2;
    SERVICE_DEMAND_START        = $3;
    SERVICE_DISABLED            = $4;
    SERVICE_DELETE              = $10000;
    SERVICE_CONTROL_STOP        = $1;
    SERVICE_CONTROL_PAUSE       = $2;
    SERVICE_CONTROL_CONTINUE    = $3;
    SERVICE_CONTROL_INTERROGATE = $4;
    SERVICE_STOPPED             = $1;
    SERVICE_START_PENDING       = $2;
    SERVICE_STOP_PENDING        = $3;
    SERVICE_RUNNING             = $4;
    SERVICE_CONTINUE_PENDING    = $5;
    SERVICE_PAUSE_PENDING       = $6;
    SERVICE_PAUSED              = $7;

// #######################################################################################
// nt based service utilities
// #######################################################################################
function OpenSCManager(lpMachineName, lpDatabaseName: string; dwDesiredAccess :cardinal): HANDLE;
external 'OpenSCManagerA@advapi32.dll stdcall';

function OpenService(hSCManager :HANDLE;lpServiceName: string; dwDesiredAccess :cardinal): HANDLE;
external 'OpenServiceA@advapi32.dll stdcall';

function CloseServiceHandle(hSCObject :HANDLE): boolean;
external 'CloseServiceHandle@advapi32.dll stdcall';

function CreateService(hSCManager :HANDLE;lpServiceName, lpDisplayName: string;dwDesiredAccess,dwServiceType,dwStartType,dwErrorControl: cardinal;lpBinaryPathName,lpLoadOrderGroup: String; lpdwTagId : cardinal;lpDependencies,lpServiceStartName,lpPassword :string): cardinal;
external 'CreateServiceA@advapi32.dll stdcall';

function DeleteService(hService :HANDLE): boolean;
external 'DeleteService@advapi32.dll stdcall';

function StartNTService(hService :HANDLE;dwNumServiceArgs : cardinal;lpServiceArgVectors : cardinal) : boolean;
external 'StartServiceA@advapi32.dll stdcall';

function ControlService(hService :HANDLE; dwControl :cardinal;var ServiceStatus :SERVICE_STATUS) : boolean;
external 'ControlService@advapi32.dll stdcall';

function QueryServiceStatus(hService :HANDLE;var ServiceStatus :SERVICE_STATUS) : boolean;
external 'QueryServiceStatus@advapi32.dll stdcall';

function QueryServiceStatusEx(hService :HANDLE;ServiceStatus :SERVICE_STATUS) : boolean;
external 'QueryServiceStatus@advapi32.dll stdcall';

function GetLastError() : cardinal;
external 'GetLastError@kernel32.dll stdcall';

function OpenServiceManager() : HANDLE;
begin
    if UsingWinNT() = true then begin
        Result := OpenSCManager('','',SC_MANAGER_ALL_ACCESS);
        if Result = 0 then
            MsgBox('the servicemanager is not available', mbError, MB_OK)
    end
    else begin
            MsgBox('only nt based systems support services', mbError, MB_OK)
            Result := 0;
    end
end;

function IsServiceInstalled(ServiceName: string) : boolean;
var
    hSCM    : HANDLE;
    hService: HANDLE;
begin
    hSCM := OpenServiceManager();
    Result := false;
    if hSCM <> 0 then begin
        hService := OpenService(hSCM,ServiceName,SERVICE_QUERY_CONFIG);
        if hService <> 0 then begin
            Result := true;
            CloseServiceHandle(hService)
        end;
        CloseServiceHandle(hSCM)
    end
end;

function InstallService(FileName, ServiceName, DisplayName, Description : string;ServiceType,StartType :cardinal) : boolean;
var
    hSCM    : HANDLE;
    hService: HANDLE;
begin
    hSCM := OpenServiceManager();
    Result := false;
    if hSCM <> 0 then begin
        hService := CreateService(hSCM,ServiceName,DisplayName,SERVICE_ALL_ACCESS,ServiceType,StartType,0,FileName,'',0,'','','');
        if hService <> 0 then begin
            Result := true;
            // Win2K & WinXP supports aditional description text for services
            if Description<> '' then
                RegWriteStringValue(HKLM,'System\CurrentControlSet\Services\' + ServiceName,'Description',Description);
            CloseServiceHandle(hService)
        end;
        CloseServiceHandle(hSCM)
    end
end;

function RemoveService(ServiceName: string) : boolean;
var
    hSCM    : HANDLE;
    hService: HANDLE;
begin
    hSCM := OpenServiceManager();
    Result := false;
    if hSCM <> 0 then begin
        hService := OpenService(hSCM,ServiceName,SERVICE_DELETE);
        if hService <> 0 then begin
            Result := DeleteService(hService);
            CloseServiceHandle(hService)
        end;
        CloseServiceHandle(hSCM)
    end
end;

function StartService(ServiceName: string) : boolean;
var
    hSCM    : HANDLE;
    hService: HANDLE;
begin
    hSCM := OpenServiceManager();
    Result := false;
    if hSCM <> 0 then begin
        hService := OpenService(hSCM,ServiceName,SERVICE_START);
        if hService <> 0 then begin
            Result := StartNTService(hService,0,0);
            CloseServiceHandle(hService)
        end;
        CloseServiceHandle(hSCM)
    end;
end;

function StopService(ServiceName: string) : boolean;
var
    hSCM    : HANDLE;
    hService: HANDLE;
    Status  : SERVICE_STATUS;
begin
    hSCM := OpenServiceManager();
    Result := false;
    if hSCM <> 0 then begin
        hService := OpenService(hSCM,ServiceName,SERVICE_STOP);
        if hService <> 0 then begin
            Result := ControlService(hService,SERVICE_CONTROL_STOP,Status);
            CloseServiceHandle(hService)
        end;
        CloseServiceHandle(hSCM)
    end;
end;

function IsServiceRunning(ServiceName: string) : boolean;
var
    hSCM    : HANDLE;
    hService: HANDLE;
    Status  : SERVICE_STATUS;
begin
    hSCM := OpenServiceManager();
    Result := false;
    if hSCM <> 0 then begin
        hService := OpenService(hSCM,ServiceName,SERVICE_QUERY_STATUS);
        if hService <> 0 then begin
            if QueryServiceStatus(hService,Status) then begin
                Result :=(Status.dwCurrentState = SERVICE_RUNNING)
            end;
            CloseServiceHandle(hService)
            end;
        CloseServiceHandle(hSCM)
    end
end;

procedure ExitProcess(exitCode:integer);
  external 'ExitProcess@kernel32.dll stdcall';

procedure IsInuServiceInstalled() ;
begin
   if IsServiceInstalled('InuService') = true then
   begin
        MsgBox('The InuDev version installed on this computer is too old.   Please uninstall it manually (Start -> Control Panel -> Uninstall a program -> InuDev -> Uninstall).   Then install this new version', mbError, MB_OK);
        ExitProcess(0);
        CancelWithoutPrompt := true;
   end;
end;

[Files]
; NOTE: Don't use "Flags: ignoreversion" on any shared system files
Source: "bin\bootfix"; DestDir: "{app}\bin"; Flags: ignoreversion
